package vie.simulation;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import vie.embedding.Algorithm1;
import vie.embedding.Algorithm2;
import vie.embedding.Algorithm3;
import vie.embedding.Mapper;
import vie.models.Link;
import vie.models.Node;
import vie.models.Pair;
import vie.models.Path;
import vie.models.PathNode;
import vie.models.PhysicalLink;
import vie.models.PhysicalNode;
import vie.models.Topology;
import vie.models.VirtualLink;
import vie.models.VirtualNode;
import vie.models.VirtualRequest;
import vie.utilities.DijkstraShortestPath;
import vie.utilities.NetworkTopology;
import vie.utilities.TopologyUtil;

public class Simulator {

	private int numberOfRequests = 100;    		// Default value for number of virtual request generated by simulator
	private int maxNodes = 4;					// Default value for max number of virtual nodes per virtual request
	
	private Topology topology;					// Topology generated by adjacency matrix

	private List<VirtualRequest> requests;		// List of virtual requests

	
	/**
	 * Constructor reads adjacency matrix for specified topology type
	 * @param type - Type of topology being used
	 * @throws IOException
	 */
	public Simulator(NetworkTopology type) throws IOException{
		this.topology = TopologyUtil.readAdjacencyMatrix(type);
	}
	
	// --------------------------------------- ACCESSORS -------------------------------------- //
	
	/**
	 * Gets the number of virtual requests the simulator is set to generate
	 * @return number of virtual request the simulator will generate
	 */
	public int getNumberOfRequests(){
		return numberOfRequests;
	}
	
	/**
	 * Gets the max number of nodes allowed for each virtual requests generated by the simulator
	 * @return max number of virtual nodes allowed for each virtual request
	 */
	public int getMaxNodes(){
		return maxNodes;
	}
	
	/**
	 * Gets the topology object generated by simulator
	 * @return topology object
	 */
	public Topology getTopology(){
		return topology;
	}
	
	// ---------------------------------------- MUTATORS ---------------------------------------- // 
	
	/**
	 * Sets the number of virtual requests the simulator must create
	 * @param numberOfRequests
	 */
	public void setNumberOfRequest(int numberOfRequests){
		this.numberOfRequests = numberOfRequests;
	}
	
	/**
	 * Sets the max number of virtual nodes a virtual request is allowed to have
	 * @param maxNodes
	 */
	public void setMaxNodes(int maxNodes){
		this.maxNodes = maxNodes;
	}
	
	// ---------------------------------------- OTHER METHODS ----------------------------------- //
	
	/**
	 * Generates number of requests. Default value is 100 requests unless other wise specified.
	 */
	public void generateRequests(){
		if(requests == null) this.requests = new ArrayList<>();

		for (int requestNumber = 0; requestNumber < numberOfRequests; requestNumber++){
			VirtualRequest request = new VirtualRequest(maxNodes, topology.getType());
			requests.add(request);
		}
	}
	
	/**
	 * Attempts to map all virtual requests generated using the specified algorithm
	 * @param algorithm
	 */
	public void start(int algorithm){		
		
		for(VirtualRequest vr: requests){
			Mapper mapper = null;
			
			switch(algorithm){
			case 1:		mapper = new Algorithm1(topology, vr);
					 	break;
			case 2:  	mapper = new Algorithm2(topology, vr);
						break;
			case 3:		mapper = new Algorithm3(topology, vr);
						break;
			}

			if (mapper.attemptRequestMapping()) topology.requestsMapped++;
		}
	}
	
	private void updateTransponderBandwidth(Path path, int traffic){
		PathNode current = path.getStart();
		while(current != null){
			if(current.getNodeID() == path.getStart().getNodeID()){
				topology.getNodes().get(current.getNodeID()).incrementTBC(traffic);
			}
			else if(!current.hasNext()){
				topology.getNodes().get(current.getNodeID()).incrementRBC(traffic);
			}
			else{
				topology.getNodes().get(current.getNodeID()).incrementTBC(traffic);
				topology.getNodes().get(current.getNodeID()).incrementRBC(traffic);
			}

			current = current.next();
		}
	}
	
	public int getTranspondersODU(int transponderCapacity, int maxBandwidth, String distribution, boolean backupPath){
		
		for(VirtualRequest vr: requests){
			List<VirtualNode> virtualNodes = vr.getVirtualNodes();
			int start = virtualNodes.get(0).getMapID();
			int finish = virtualNodes.get(virtualNodes.size() - 1).getMapID();
			
			int traffic = -1;
			while(traffic <= 0 || traffic > maxBandwidth){
			traffic = (distribution.equals("uniform"))?Link.generateRandomBandwidthUniform(maxBandwidth):
								  (distribution.equals("gaussian"))?Link.generateRandomBandwidthGaussian(maxBandwidth):
												  					Link.generateRandomBandwidth(maxBandwidth);
			}
			
			DijkstraShortestPath dsp = new DijkstraShortestPath(topology, start, finish);
			updateTransponderBandwidth(dsp.getShortestPath(), traffic);
			
			if(backupPath) updateTransponderBandwidth(dsp.getDisjointShortestPath(), traffic);			
		}
		
		int totalTranspondersODU = 0;

		for(int i = 0; i < topology.getType().getNumberOfPhysicalNodes(); i++){
			int transmittersNeeded = ((topology.getNodes().get(i).getTransmissionBandwidth() / transponderCapacity) + ((topology.getNodes().get(i).getTransmissionBandwidth() % transponderCapacity != 0)? 1:0));
			int receiversNeeded = ((topology.getNodes().get(i).getReceivingBandwidth() / transponderCapacity) + ((topology.getNodes().get(i).getReceivingBandwidth() % transponderCapacity != 0)? 1:0));
			totalTranspondersODU += (transmittersNeeded + receiversNeeded);
		}
		
		return totalTranspondersODU;
	}
	
	public int getTransponderOTN(int transponderCapacity,int maxBandwidth, String distribution, boolean backupPath){
		
		int totalTranspondersOTN = 0; 
		
		for(int i = 0; i < numberOfRequests; i++){
			int traffic = -1;
			while(traffic <= 0 || traffic > maxBandwidth){
			traffic = (distribution.equals("uniform"))?Link.generateRandomBandwidthUniform(maxBandwidth):
								  (distribution.equals("gaussian"))?Link.generateRandomBandwidthGaussian(maxBandwidth):
												  					Link.generateRandomBandwidth(maxBandwidth);
			}
			
			totalTranspondersOTN += ((traffic / transponderCapacity) + ((traffic % transponderCapacity != 0)? 1:0)) * 2;
		}
		
		return totalTranspondersOTN;
	}
	
	
	/**
	 * Removes all mappings for all virtual requests and returns all resources to physical links 
	 * and physical nodes
	 */
	public void resetAllResources(){
		
		topology.requestsMapped = 0;
		
		for(VirtualRequest vr: requests){
			if(vr.isBlocked())
				vr.unblock();
			for(int i = 1; i < vr.getVirtualNodes().size() - 1; i++)
				vr.getVirtualNodes().get(i).setMap(-1);
			for(VirtualLink vl: vr.getVirtualLinks())
				vl.setLinkMapping(null);
		}
		
		for(Map.Entry<Integer, PhysicalNode> entry: topology.getNodes().entrySet())
			entry.getValue().setComputationAvailability(Topology.COMPUTATIONAL_AVAILABILITY);
		
		for(PhysicalLink pl: topology.getLinks())
			pl.setBandwidthAvailability(Topology.BANDWIDTH_AVAILABILITY);
	}
	
}
